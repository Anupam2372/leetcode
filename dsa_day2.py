# -*- coding: utf-8 -*-
"""DSA_Day2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1D48ye3eRdkKO53kbvg17f2XLUI-tOoVi
"""

## This is based on Recurssion problem

# write function to calculate the factorial using rescursion

def factorial(n):
  if n==0:
    return 1
  return factorial(n-1)*n

factorial(5)

factorial(6)

# write code for 321123 type of printing using the recursion
def print_fact(n):
  if n==0:
    return 1
  print(n)
  print_fact(n-1)
  print(n)

print_fact(3)

# Print the Fibonacci number
# F(n) = F(n-1) + F(n-2)
# F(0) = 0
# F(1) = 1

def Fibonacci(n):

  if n <= 0:
    return 0
  elif n == 1:
    return 1
  else:
    return Fibonacci(n-1) + Fibonacci(n-2)

Fibonacci(5)

"""### K-th Symbol in Grammar
We build a table of n rows (1-indexed). We start by writing O in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.

For example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3ra row is 0110.Given two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows

for n = 4

0

01

0110

01101001

"""

def kSymbol_Grammer(n,k):
  sz = 2**(n-1) # Total number of elements
  if n==1:
    return 0

  # index information
  if k > sz/2:
    k = k - sz/2
    return 1 - kSymbol_Grammer(n-1,k)
  else:
    return kSymbol_Grammer(n-1,k)

kSymbol_Grammer(4,7)

for k in list(range(1,5)):
  print(kSymbol_Grammer(3,k))

for k in list(range(1,9)):
  print(kSymbol_Grammer(4,k))

"""### Josephus problem: Find the Winner of the Circular Game

There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.
The rules of the game are as follows:
1. Start at the 1st friend.
2. Count the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.
3. The last friend you counted leaves the circle and loses the game.
4. If there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.
5. Else, the last friend in the circle wins the game.
Given the number of friends, n, and an integer k, return the winner of the

#### Constraints:
1 <= k <= n <= 500
"""

# Approach 1
def Josephus_problem(arr, k):
    if len(arr) == 1:
        return arr[0]
    remove = (0 + k - 1) % len(arr)
    arr.pop(remove)
    # Rotate the list so that the element after the removed one starts at index 0
    arr = arr[remove:] + arr[:remove]
    return Josephus_problem(arr, k)

n = 5
k = 2
arr = list(range(1,n+1))
Josephus_problem(arr,k)

n = 6
k = 5
arr = list(range(1,n+1))
Josephus_problem(arr,k)

"""### Tower Of Hanoi

In the Tower of Hanoi puzzle, you are given n disks stacked in ascending order (smallest at the top) on the first of three rods. The goal is to move all disks to the third rod following two rules: only one disk can be moved at a time, and a disk can only be placed on top of a larger disk. Given the number of disks n and three rods labeled as from, to, and aux (starting rod, target rod, and auxiliary rod, respectively),  returns the total number of moves needed to transfer all disks from the starting rod to the target rod.
"""





